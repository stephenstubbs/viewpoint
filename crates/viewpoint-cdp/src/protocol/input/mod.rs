//! Input domain types.
//!
//! The Input domain provides methods for simulating user input events.

use serde::Serialize;

/// Mouse button type.
#[derive(Debug, Clone, Copy, Serialize)]
#[serde(rename_all = "lowercase")]
pub enum MouseButton {
    None,
    Left,
    Middle,
    Right,
    Back,
    Forward,
}

/// Type of mouse event.
#[derive(Debug, Clone, Copy, Serialize)]
#[serde(rename_all = "camelCase")]
pub enum MouseEventType {
    MousePressed,
    MouseReleased,
    MouseMoved,
    MouseWheel,
}

/// Type of key event.
#[derive(Debug, Clone, Copy, Serialize)]
#[serde(rename_all = "camelCase")]
pub enum KeyEventType {
    KeyDown,
    KeyUp,
    RawKeyDown,
    Char,
}

/// Parameters for Input.dispatchMouseEvent.
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct DispatchMouseEventParams {
    /// Type of the mouse event.
    #[serde(rename = "type")]
    pub event_type: MouseEventType,
    /// X coordinate of the event relative to the main frame's viewport.
    pub x: f64,
    /// Y coordinate of the event relative to the main frame's viewport.
    pub y: f64,
    /// Mouse button.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub button: Option<MouseButton>,
    /// Number of times the mouse button was clicked.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub click_count: Option<i32>,
    /// Bit field representing pressed modifier keys.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub modifiers: Option<i32>,
    /// Time at which the event occurred.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<f64>,
}

impl DispatchMouseEventParams {
    /// Create a mouse move event.
    pub fn mouse_move(x: f64, y: f64) -> Self {
        Self {
            event_type: MouseEventType::MouseMoved,
            x,
            y,
            button: None,
            click_count: None,
            modifiers: None,
            timestamp: None,
        }
    }

    /// Create a mouse down event.
    pub fn mouse_down(x: f64, y: f64, button: MouseButton) -> Self {
        Self {
            event_type: MouseEventType::MousePressed,
            x,
            y,
            button: Some(button),
            click_count: Some(1),
            modifiers: None,
            timestamp: None,
        }
    }

    /// Create a mouse up event.
    pub fn mouse_up(x: f64, y: f64, button: MouseButton) -> Self {
        Self {
            event_type: MouseEventType::MouseReleased,
            x,
            y,
            button: Some(button),
            click_count: Some(1),
            modifiers: None,
            timestamp: None,
        }
    }

    /// Create a mouse wheel event.
    pub fn mouse_wheel(x: f64, y: f64, delta_x: f64, delta_y: f64) -> DispatchMouseWheelParams {
        DispatchMouseWheelParams {
            event_type: MouseEventType::MouseWheel,
            x,
            y,
            delta_x,
            delta_y,
            modifiers: None,
            pointer_type: None,
        }
    }
}

/// Parameters for Input.dispatchMouseEvent with wheel.
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct DispatchMouseWheelParams {
    /// Type of the mouse event.
    #[serde(rename = "type")]
    pub event_type: MouseEventType,
    /// X coordinate of the event relative to the main frame's viewport.
    pub x: f64,
    /// Y coordinate of the event relative to the main frame's viewport.
    pub y: f64,
    /// X delta in CSS pixels for mouse wheel event.
    pub delta_x: f64,
    /// Y delta in CSS pixels for mouse wheel event.
    pub delta_y: f64,
    /// Bit field representing pressed modifier keys.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub modifiers: Option<i32>,
    /// Pointer type (default "mouse").
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pointer_type: Option<String>,
}

/// Parameters for Input.dispatchKeyEvent.
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct DispatchKeyEventParams {
    /// Type of the key event.
    #[serde(rename = "type")]
    pub event_type: KeyEventType,
    /// Bit field representing pressed modifier keys.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub modifiers: Option<i32>,
    /// Time at which the event occurred.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<f64>,
    /// Text as generated by processing a virtual key code.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
    /// Text that would have been generated without any modifiers.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unmodified_text: Option<String>,
    /// Unique key identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_identifier: Option<String>,
    /// Unique DOM defined string value for each key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    /// Unique DOM defined string value describing the meaning of the key.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// Windows virtual key code.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub windows_virtual_key_code: Option<i32>,
    /// Native virtual key code.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub native_virtual_key_code: Option<i32>,
    /// Whether the event was generated from auto repeat.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auto_repeat: Option<bool>,
    /// Whether the event was generated from the keypad.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_keypad: Option<bool>,
    /// Whether the event was a system key event.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_system_key: Option<bool>,
    /// Editing commands to send with the event.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub commands: Option<Vec<String>>,
}

impl DispatchKeyEventParams {
    /// Create a key down event.
    pub fn key_down(key: &str) -> Self {
        Self {
            event_type: KeyEventType::KeyDown,
            modifiers: None,
            timestamp: None,
            text: None,
            unmodified_text: None,
            key_identifier: None,
            code: Some(key.to_string()),
            key: Some(key.to_string()),
            windows_virtual_key_code: None,
            native_virtual_key_code: None,
            auto_repeat: None,
            is_keypad: None,
            is_system_key: None,
            commands: None,
        }
    }

    /// Create a key up event.
    pub fn key_up(key: &str) -> Self {
        Self {
            event_type: KeyEventType::KeyUp,
            modifiers: None,
            timestamp: None,
            text: None,
            unmodified_text: None,
            key_identifier: None,
            code: Some(key.to_string()),
            key: Some(key.to_string()),
            windows_virtual_key_code: None,
            native_virtual_key_code: None,
            auto_repeat: None,
            is_keypad: None,
            is_system_key: None,
            commands: None,
        }
    }

    /// Create a char event for text input.
    pub fn char(text: &str) -> Self {
        Self {
            event_type: KeyEventType::Char,
            modifiers: None,
            timestamp: None,
            text: Some(text.to_string()),
            unmodified_text: Some(text.to_string()),
            key_identifier: None,
            code: None,
            key: None,
            windows_virtual_key_code: None,
            native_virtual_key_code: None,
            auto_repeat: None,
            is_keypad: None,
            is_system_key: None,
            commands: None,
        }
    }
}

/// Parameters for Input.insertText.
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct InsertTextParams {
    /// The text to insert.
    pub text: String,
}

/// Modifier keys bit flags.
pub mod modifiers {
    pub const ALT: i32 = 1;
    pub const CTRL: i32 = 2;
    pub const META: i32 = 4;
    pub const SHIFT: i32 = 8;
}

/// Type of touch event.
#[derive(Debug, Clone, Copy, Serialize)]
#[serde(rename_all = "camelCase")]
pub enum TouchEventType {
    TouchStart,
    TouchEnd,
    TouchMove,
    TouchCancel,
}

/// A single touch point.
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct TouchPoint {
    /// X coordinate of the touch point.
    pub x: f64,
    /// Y coordinate of the touch point.
    pub y: f64,
    /// Touch point radius in X direction (default 1.0).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub radius_x: Option<f64>,
    /// Touch point radius in Y direction (default 1.0).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub radius_y: Option<f64>,
    /// Rotation angle (default 0.0).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rotation_angle: Option<f64>,
    /// Force (default 1.0).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force: Option<f64>,
    /// Touch point id. Useful for multi-touch.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<i32>,
}

impl TouchPoint {
    /// Create a new touch point at the given coordinates.
    pub fn new(x: f64, y: f64) -> Self {
        Self {
            x,
            y,
            radius_x: None,
            radius_y: None,
            rotation_angle: None,
            force: None,
            id: None,
        }
    }

    /// Set the touch point ID.
    #[must_use]
    pub fn with_id(mut self, id: i32) -> Self {
        self.id = Some(id);
        self
    }
}

/// Parameters for Input.dispatchTouchEvent.
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct DispatchTouchEventParams {
    /// Type of the touch event.
    #[serde(rename = "type")]
    pub event_type: TouchEventType,
    /// Active touch points on the touch device.
    pub touch_points: Vec<TouchPoint>,
    /// Bit field representing pressed modifier keys.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub modifiers: Option<i32>,
    /// Time at which the event occurred.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<f64>,
}

impl DispatchTouchEventParams {
    /// Create a touch start event.
    pub fn touch_start(x: f64, y: f64) -> Self {
        Self {
            event_type: TouchEventType::TouchStart,
            touch_points: vec![TouchPoint::new(x, y)],
            modifiers: None,
            timestamp: None,
        }
    }

    /// Create a touch end event.
    pub fn touch_end() -> Self {
        Self {
            event_type: TouchEventType::TouchEnd,
            touch_points: vec![],
            modifiers: None,
            timestamp: None,
        }
    }

    /// Create a touch move event.
    pub fn touch_move(x: f64, y: f64) -> Self {
        Self {
            event_type: TouchEventType::TouchMove,
            touch_points: vec![TouchPoint::new(x, y)],
            modifiers: None,
            timestamp: None,
        }
    }

    /// Create a touch cancel event.
    pub fn touch_cancel() -> Self {
        Self {
            event_type: TouchEventType::TouchCancel,
            touch_points: vec![],
            modifiers: None,
            timestamp: None,
        }
    }
}

/// Type of drag event.
#[derive(Debug, Clone, Copy, Serialize)]
#[serde(rename_all = "camelCase")]
pub enum DragEventType {
    DragEnter,
    DragOver,
    Drop,
    DragCancel,
}

/// Drag data item.
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct DragDataItem {
    /// Mime type of the data.
    pub mime_type: String,
    /// Depending on the value of `mime_type`, it contains the drag data string or base64-encoded binary data.
    pub data: String,
}

/// Drag data.
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct DragData {
    /// Items in the drag data.
    pub items: Vec<DragDataItem>,
    /// Drag operations mask.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub drag_operations_mask: Option<i32>,
}

impl DragData {
    /// Create empty drag data.
    pub fn new() -> Self {
        Self {
            items: vec![],
            drag_operations_mask: None,
        }
    }

    /// Add a text item.
    #[must_use]
    pub fn with_text(mut self, text: &str) -> Self {
        self.items.push(DragDataItem {
            mime_type: "text/plain".to_string(),
            data: text.to_string(),
        });
        self
    }
}

impl Default for DragData {
    fn default() -> Self {
        Self::new()
    }
}

/// Parameters for Input.dispatchDragEvent.
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct DispatchDragEventParams {
    /// Type of the drag event.
    #[serde(rename = "type")]
    pub event_type: DragEventType,
    /// X coordinate of the event relative to the main frame's viewport.
    pub x: f64,
    /// Y coordinate of the event relative to the main frame's viewport.
    pub y: f64,
    /// Drag data.
    pub data: DragData,
    /// Bit field representing pressed modifier keys.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub modifiers: Option<i32>,
}
